use once_cell::sync::Lazy;
use std::collections::{HashMap, HashSet};

use fhir::{FhirVersion, FhirResourceTypeProvider};

/// FHIR Type Hierarchy module
///
/// This module provides a comprehensive model of the FHIR type hierarchy
/// and utility functions for type checking, type conversion, and type reflection.
/// It models both resource types (Patient, Observation, etc.) and data types
/// (boolean, string, Quantity, etc.) with their inheritance relationships.
///
/// # Key Features
///
/// - **Version-aware resource type checking**: Uses the actual Resource enum variants 
///   from each FHIR version instead of hardcoded lists
/// - **Namespace management**: Handles both FHIR and System namespaces with proper
///   type classification
/// - **Dynamic type discovery**: Leverages the `FhirResourceTypeProvider` trait 
///   generated by procedural macros
/// - **Type conversion utilities**: Functions for converting between namespaces
///   and determining type classifications
///
/// # Architecture
///
/// The module is built around the concept that FHIR type information should be
/// extracted from the actual FHIR specification rather than hardcoded. This is
/// achieved through:
///
/// 1. **Generated Trait Implementations**: The `FhirResourceTypeProvider` trait is
///    automatically implemented for each FHIR version's Resource enum
/// 2. **Version Context**: All resource type checking functions require a `FhirVersion`
///    parameter to ensure version-specific accuracy
/// 3. **Compile-time Safety**: Type information is extracted at compile time,
///    ensuring it stays in sync with the FHIR models
///
/// # Usage Examples
///
/// ```rust
/// use fhir::FhirVersion;
/// use fhirpath::fhir_type_hierarchy::{
///     is_fhir_resource_type, 
///     determine_type_namespace_with_version,
///     FHIR_NAMESPACE, SYSTEM_NAMESPACE
/// };
///
/// // Check if a type is a FHIR resource in a specific version
/// let is_patient = is_fhir_resource_type("Patient", FhirVersion::R4); // true
/// let is_unknown = is_fhir_resource_type("UnknownType", FhirVersion::R4); // false
///
/// // Determine the appropriate namespace for a type
/// let patient_ns = determine_type_namespace_with_version("Patient", FhirVersion::R4);
/// assert_eq!(patient_ns, FHIR_NAMESPACE);
///
/// let boolean_ns = determine_type_namespace_with_version("Boolean", FhirVersion::R4);
/// assert_eq!(boolean_ns, SYSTEM_NAMESPACE);
/// ```
///
/// # Version-Specific Behavior
///
/// Different FHIR versions may have different resource types. For example:
/// - Some resources may be added in newer versions
/// - Some resources may be deprecated or renamed between versions
/// - Resource inheritance relationships may change
///
/// This module ensures that type checking is always performed against the
/// correct set of types for the specified FHIR version.

/// Constants for namespaces
pub const SYSTEM_NAMESPACE: &str = "System";
pub const FHIR_NAMESPACE: &str = "FHIR";

/// Set of FHIR primitive types
static FHIR_PRIMITIVE_TYPES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    let mut s = HashSet::new();
    s.insert("boolean");
    s.insert("string");
    s.insert("integer");
    s.insert("decimal");
    s.insert("date");
    s.insert("dateTime");
    s.insert("time");
    s.insert("code");
    s.insert("id");
    s.insert("uri");
    s.insert("url");
    s.insert("canonical");
    s.insert("markdown");
    s.insert("base64Binary");
    s.insert("instant");
    s.insert("oid");
    s.insert("positiveInt");
    s.insert("unsignedInt");
    s.insert("uuid");
    s
});

/// Set of FHIR complex data types
static FHIR_COMPLEX_TYPES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    let mut s = HashSet::new();
    s.insert("Quantity");
    s.insert("Money");
    s.insert("Period");
    s.insert("Range");
    s.insert("Ratio");
    s.insert("Reference");
    s.insert("HumanName");
    s.insert("Address");
    s.insert("ContactPoint");
    s.insert("Identifier");
    s.insert("CodeableConcept");
    s.insert("Coding");
    s.insert("Attachment");
    s.insert("Timing");
    s.insert("Signature");
    s.insert("Annotation");
    s.insert("SampledData");
    s.insert("Age");
    s.insert("Distance");
    s.insert("Duration");
    s.insert("Count");
    s
});

/// Set of System primitive types
static SYSTEM_PRIMITIVE_TYPES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    let mut s = HashSet::new();
    s.insert("Boolean");
    s.insert("String");
    s.insert("Integer");
    s.insert("Decimal");
    s.insert("Date");
    s.insert("DateTime");
    s.insert("Time");
    s.insert("Quantity");
    s
});

/// Mapping from FHIR primitive types to their equivalent System types
static FHIR_TO_SYSTEM_TYPE_MAP: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert("boolean", "Boolean");
    m.insert("string", "String");
    m.insert("integer", "Integer");
    m.insert("decimal", "Decimal");
    m.insert("date", "Date");
    m.insert("dateTime", "DateTime");
    m.insert("time", "Time");
    m.insert("Quantity", "Quantity"); // Complex type that exists in both namespaces
    m
});

/// Checks if a type is a FHIR primitive type
pub fn is_fhir_primitive_type(type_name: &str) -> bool {
    FHIR_PRIMITIVE_TYPES.contains(type_name.to_lowercase().as_str())
}

/// Checks if a type is a FHIR complex data type
pub fn is_fhir_complex_type(type_name: &str) -> bool {
    FHIR_COMPLEX_TYPES.contains(capitalize_first_letter(type_name).as_str())
}

/// Checks if a type is a System primitive type
pub fn is_system_primitive_type(type_name: &str) -> bool {
    SYSTEM_PRIMITIVE_TYPES.contains(capitalize_first_letter(type_name).as_str())
}

/// Checks if a type name is a known FHIR resource type for the given FHIR version
///
/// This function performs version-aware resource type checking by consulting the
/// actual Resource enum variants for the specified FHIR version. It uses the
/// `FhirResourceTypeProvider` trait that is automatically generated for each
/// FHIR version's Resource enum.
///
/// # Arguments
///
/// * `type_name` - The type name to check (case-insensitive)
/// * `version` - The FHIR version to check against
///
/// # Returns
///
/// `true` if the type is a known resource type in the specified FHIR version,
/// `false` otherwise.
///
/// # Examples
///
/// ```rust
/// use fhir::FhirVersion;
/// use fhirpath::fhir_type_hierarchy::is_fhir_resource_type;
///
/// // Check common resource types
/// assert!(is_fhir_resource_type("Patient", FhirVersion::R4));
/// assert!(is_fhir_resource_type("Observation", FhirVersion::R4));
/// assert!(is_fhir_resource_type("Resource", FhirVersion::R4)); // Base resource
///
/// // Case insensitive
/// assert!(is_fhir_resource_type("patient", FhirVersion::R4));
/// assert!(is_fhir_resource_type("PATIENT", FhirVersion::R4));
///
/// // Non-resource types
/// assert!(!is_fhir_resource_type("boolean", FhirVersion::R4));
/// assert!(!is_fhir_resource_type("UnknownType", FhirVersion::R4));
/// ```
///
/// # Version-Specific Behavior
///
/// Different FHIR versions may have different sets of resource types:
///
/// ```rust
/// // Some resources might exist in one version but not another
/// let exists_in_r4 = is_fhir_resource_type("SomeResource", FhirVersion::R4);
/// let exists_in_r5 = is_fhir_resource_type("SomeResource", FhirVersion::R5);
/// // Results may differ based on when the resource was introduced
/// ```
pub fn is_fhir_resource_type(type_name: &str, version: FhirVersion) -> bool {
    // Handle "Resource" directly (special case)
    if type_name.eq_ignore_ascii_case("Resource") {
        return true;
    }

    // Handle "DomainResource" (base class for many resources)
    if type_name.eq_ignore_ascii_case("DomainResource") {
        return true;
    }

    // Use the generated FhirResourceTypeProvider trait implementation
    match version {
        #[cfg(feature = "R4")]
        FhirVersion::R4 => fhir::r4::Resource::is_resource_type(type_name),
        #[cfg(feature = "R4B")]
        FhirVersion::R4B => fhir::r4b::Resource::is_resource_type(type_name),
        #[cfg(feature = "R5")]
        FhirVersion::R5 => fhir::r5::Resource::is_resource_type(type_name),
        #[cfg(feature = "R6")]
        FhirVersion::R6 => fhir::r6::Resource::is_resource_type(type_name),
    }
}

/// Gets the appropriate namespace for a primitive type name
///
/// # Arguments
///
/// * `type_name` - The type name to check
///
/// # Returns
///
/// * The namespace ("System" or "FHIR") for the given type
pub fn get_primitive_type_namespace(type_name: &str) -> &'static str {
    // Check if the name starts with uppercase (System namespace)
    // or lowercase (FHIR namespace)
    let first_char = type_name.chars().next().unwrap_or('_');
    if first_char.is_uppercase() {
        SYSTEM_NAMESPACE
    } else {
        FHIR_NAMESPACE
    }
}

/// Converts a type name from one namespace to the other
///
/// # Arguments
///
/// * `type_name` - The type name to convert
/// * `target_namespace` - The target namespace ("System" or "FHIR")
///
/// # Returns
///
/// * The equivalent type name in the target namespace, or None if not convertible
pub fn convert_type_namespace(type_name: &str, target_namespace: &str) -> Option<String> {
    let normalized = type_name.to_lowercase();

    match target_namespace {
        SYSTEM_NAMESPACE => {
            // Convert FHIR type to System type
            FHIR_TO_SYSTEM_TYPE_MAP
                .get(normalized.as_str())
                .map(|&system_type| system_type.to_string())
        }
        FHIR_NAMESPACE => {
            // Convert System type to FHIR type
            for (fhir_type, system_type) in FHIR_TO_SYSTEM_TYPE_MAP.iter() {
                if system_type.eq_ignore_ascii_case(type_name) {
                    return Some((*fhir_type).to_string());
                }
            }
            None
        }
        _ => None,
    }
}

/// Utility function to capitalize the first letter of a string
///
/// # Arguments
///
/// * `s` - The string to capitalize
///
/// # Returns
///
/// * A new string with the first letter capitalized
pub fn capitalize_first_letter(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => {
            let cap = c.to_uppercase().collect::<String>();
            cap + chars.as_str()
        }
    }
}


/// Determines the most specific namespace for a type with a specific FHIR version
///
/// For unqualified type names, this determines whether the type should be in the 
/// System or FHIR namespace based on conventions and the specific FHIR version.
/// This function provides version-aware namespace determination that ensures
/// accurate type classification.
///
/// # Namespace Classification Rules
///
/// 1. **FHIR Resource Types**: Types that are valid FHIR resources in the specified version → FHIR namespace
/// 2. **FHIR Complex Types**: Known FHIR complex data types → FHIR namespace  
/// 3. **Case-based Classification**: 
///    - Lowercase names (`boolean`, `string`) → FHIR namespace for primitives
///    - Uppercase names (`Boolean`, `String`) → System namespace for primitives
/// 4. **Unknown Types**: Default to System namespace
///
/// # Arguments
///
/// * `type_name` - The type name to analyze (unqualified, without namespace prefix)
/// * `version` - The FHIR version to use for resource type checking
///
/// # Returns
///
/// The most appropriate namespace (`"FHIR"` or `"System"`) for the type.
///
/// # Examples
///
/// ```rust
/// use fhir::FhirVersion;
/// use fhirpath::fhir_type_hierarchy::{determine_type_namespace_with_version, FHIR_NAMESPACE, SYSTEM_NAMESPACE};
///
/// // FHIR resource types
/// assert_eq!(determine_type_namespace_with_version("Patient", FhirVersion::R4), FHIR_NAMESPACE);
/// assert_eq!(determine_type_namespace_with_version("Observation", FhirVersion::R4), FHIR_NAMESPACE);
///
/// // FHIR complex types
/// assert_eq!(determine_type_namespace_with_version("HumanName", FhirVersion::R4), FHIR_NAMESPACE);
/// assert_eq!(determine_type_namespace_with_version("Quantity", FhirVersion::R4), FHIR_NAMESPACE);
///
/// // Primitive types by case convention
/// assert_eq!(determine_type_namespace_with_version("boolean", FhirVersion::R4), FHIR_NAMESPACE);
/// assert_eq!(determine_type_namespace_with_version("Boolean", FhirVersion::R4), SYSTEM_NAMESPACE);
/// assert_eq!(determine_type_namespace_with_version("string", FhirVersion::R4), FHIR_NAMESPACE);
/// assert_eq!(determine_type_namespace_with_version("String", FhirVersion::R4), SYSTEM_NAMESPACE);
///
/// // Unknown types default to System
/// assert_eq!(determine_type_namespace_with_version("UnknownType", FhirVersion::R4), SYSTEM_NAMESPACE);
/// ```
///
/// # Version-Aware Behavior
///
/// The function's behavior may change based on the FHIR version:
///
/// ```rust
/// // A type might be a resource in one version but not another
/// let ns_r4 = determine_type_namespace_with_version("NewResource", FhirVersion::R4);
/// let ns_r5 = determine_type_namespace_with_version("NewResource", FhirVersion::R5);
/// // Results may differ if "NewResource" was introduced in R5
/// ```
pub fn determine_type_namespace_with_version(type_name: &str, version: FhirVersion) -> &'static str {
    let normalized = capitalize_first_letter(type_name);

    // Check if it's a known FHIR resource
    if is_fhir_resource_type(&normalized, version) {
        return FHIR_NAMESPACE;
    }

    // Check if it's a known FHIR complex type
    if is_fhir_complex_type(&normalized) {
        return FHIR_NAMESPACE;
    }

    // For primitive types, use the case convention
    // lowercase = FHIR, uppercase first letter = System
    let first_char = type_name.chars().next().unwrap_or('_');
    if first_char.is_lowercase() && is_fhir_primitive_type(type_name) {
        FHIR_NAMESPACE
    } else if first_char.is_uppercase() && is_system_primitive_type(type_name) {
        SYSTEM_NAMESPACE
    } else if is_fhir_primitive_type(&type_name.to_lowercase()) {
        // Default to FHIR namespace for primitive types if no clear convention
        FHIR_NAMESPACE
    } else {
        // Default to System namespace for unknown types
        SYSTEM_NAMESPACE
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_namespace_determination() {
        // Use R4 as test version
        #[cfg(feature = "R4")]
        let version = FhirVersion::R4;
        #[cfg(not(feature = "R4"))]
        let version = {
            #[cfg(feature = "R4B")]
            { FhirVersion::R4B }
            #[cfg(all(not(feature = "R4B"), feature = "R5"))]
            { FhirVersion::R5 }
            #[cfg(all(not(feature = "R4B"), not(feature = "R5"), feature = "R6"))]
            { FhirVersion::R6 }
        };

        // Test FHIR resource types
        assert_eq!(determine_type_namespace_with_version("Patient", version), FHIR_NAMESPACE);
        assert_eq!(determine_type_namespace_with_version("Resource", version), FHIR_NAMESPACE);

        // Test FHIR complex types
        assert_eq!(determine_type_namespace_with_version("HumanName", version), FHIR_NAMESPACE);
        assert_eq!(determine_type_namespace_with_version("CodeableConcept", version), FHIR_NAMESPACE);

        // Test primitive types by case
        assert_eq!(determine_type_namespace_with_version("boolean", version), FHIR_NAMESPACE);
        assert_eq!(determine_type_namespace_with_version("Boolean", version), SYSTEM_NAMESPACE);
        assert_eq!(determine_type_namespace_with_version("string", version), FHIR_NAMESPACE);
        assert_eq!(determine_type_namespace_with_version("String", version), SYSTEM_NAMESPACE);
    }

    #[test]
    fn test_namespace_conversion() {
        // Test FHIR to System conversion
        assert_eq!(
            convert_type_namespace("boolean", SYSTEM_NAMESPACE),
            Some("Boolean".to_string())
        );
        assert_eq!(
            convert_type_namespace("decimal", SYSTEM_NAMESPACE),
            Some("Decimal".to_string())
        );

        // Test System to FHIR conversion
        assert_eq!(
            convert_type_namespace("Boolean", FHIR_NAMESPACE),
            Some("boolean".to_string())
        );
        assert_eq!(
            convert_type_namespace("Decimal", FHIR_NAMESPACE),
            Some("decimal".to_string())
        );

        // Test case insensitivity
        assert_eq!(
            convert_type_namespace("BOOLEAN", SYSTEM_NAMESPACE),
            Some("Boolean".to_string())
        );
        assert_eq!(
            convert_type_namespace("Boolean", FHIR_NAMESPACE),
            Some("boolean".to_string())
        );
    }
}
